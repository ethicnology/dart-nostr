import 'package:bip340/bip340.dart' as bip340;
import 'package:nostr/src/event.dart';
import 'package:nostr/src/nips/nip_004/crypto.dart';
import 'package:nostr/src/utils.dart';

/// A special event with kind 4, meaning "encrypted direct message".
///
/// content MUST be equal to the base64-encoded, aes-256-cbc encrypted string of anything a user wants to write, encrypted using a shared cipher generated by combining the recipient's public-key with the sender's private-key;
/// this appended by the base64-encoded initialization vector as if it was a querystring parameter named "iv".
/// The format is the following: "content": "<encrypted_text>?iv=<initialization_vector>".
///
/// tags MUST contain an entry identifying the receiver of the message (such that relays may naturally forward this event to them), in the form ["p", "pubkey, as a hex string"].
///
/// tags MAY contain an entry identifying the previous message in a conversation or a message we are explicitly replying to (such that contextual, more organized conversations may happen), in the form ["e", "event_id"].
///
/// Note: By default in the libsecp256k1 ECDH implementation, the secret is the SHA256 hash of the shared point (both X and Y coordinates). In Nostr, only the X coordinate of the shared point is used as the secret and it is NOT hashed. If using libsecp256k1, a custom function that copies the X coordinate must be passed as the hashfp argument in secp256k1_ecdh.
class EncryptedDirectMessage extends Event {
  /// Default constructor
  EncryptedDirectMessage(Event event, {verify = true})
      : super(
          event.id,
          event.pubkey,
          event.createdAt,
          4,
          event.tags,
          event.content,
          event.sig,
          subscriptionId: event.subscriptionId,
          verify: verify,
        );

  /// receive an EncryptedDirectMessage
  EncryptedDirectMessage.receive(Event event, {verify = true})
      : super(
          event.id,
          event.pubkey,
          event.createdAt,
          event.kind,
          event.tags,
          event.content,
          event.sig,
          subscriptionId: event.subscriptionId,
          verify: verify,
        ) {
    assert(kind == 4);
  }

  /// prepare a EncryptedDirectMessage to send quickly with the minimal needed params
  factory EncryptedDirectMessage.redact(
    String senderPrivkey,
    String receiverPubkey,
    String message,
  ) {
    var event = Event.partial(
      pubkey: bip340.getPublicKey(senderPrivkey).toLowerCase(),
      createdAt: currentUnixTimestampSeconds(),
      kind: 4,
      tags: [
        ['p', receiverPubkey]
      ],
      content: cipher(
        senderPrivkey,
        '02$receiverPubkey',
        message,
        true,
      ),
    );
    event.id = event.getEventId();
    event.sig = event.getSignature(senderPrivkey);
    return EncryptedDirectMessage(event);
  }

  /// get receiver public key
  String? get receiver => _findTag("p");

  /// get sender public key
  String? get sender => pubkey;

  /// get previous event id â€“> MAY contain an entry identifying the previous message in a conversation or a message we are explicitly replying to.
  String? get previous => _findTag("e");

  /// get nonce/IV
  String get nonce => _findNonce();

  /// get the deciphered message a.k.a. plaintext
  String getPlaintext(String privkey) {
    String ciphertext = content.split("?iv=")[0];
    String plaintext;
    try {
      plaintext = cipher(
        privkey,
        "02$pubkey",
        ciphertext,
        false,
        nonce: nonce,
      );
    } catch (e) {
      throw Exception("Fail to decipher: $e");
    }
    return plaintext;
  }

  /// find the given tag prefix and return the value if found
  String? _findTag(String prefix) {
    String prefix = "p";
    for (List<String> tag in tags) {
      if (tag.isNotEmpty && tag[0] == prefix && tag.length > 1) return tag[1];
    }
    return null;
  }

  /// parse the ciphered content to return the nonce/IV
  String _findNonce() {
    List<String> split = content.split("?iv=");
    if (split.length != 2) throw Exception("invalid content or non ciphered");
    return split[1];
  }
}
